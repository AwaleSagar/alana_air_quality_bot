import logging
import random
from argparse import ArgumentParser

import os
from flask import Flask, request
from flask_restful import Api
from utils import log
from utils.abstract_classes import Bot
from utils.dict_query import DictQuery
from datetime import datetime
import random

from rasa.nlu.model import Interpreter, Metadata

app = Flask(__name__)
api = Api(app)
BOT_NAME = "air_quality_bot"
VERSION = log.get_short_git_version()
BRANCH = log.get_git_branch()

logger = logging.getLogger(__name__)

parser = ArgumentParser()
parser.add_argument('-p', "--port", type=int, default=5130)
parser.add_argument('-l', '--logfile', type=str, default='logs/' + BOT_NAME + '.log')
parser.add_argument('-cv', '--console-verbosity', default='info', help='Console logging verbosity')
parser.add_argument('-fv', '--file-verbosity', default='debug', help='File logging verbosity')



## RASA PARAMS
example_utterance = u"how great will air be next week"
MODEL_NAME = "nlu-20200209-173958"
MODEL = f"models/{MODEL_NAME}/nlu"

## WAGI API PARAMS
API_KEY = "dc7cf06b49047ee83091c9c350abcf80db6fbd43"
API_URL = f"https://api.waqi.info/feed/edinburgh/?token={api_key}"

class GreetingsBot(Bot):
    def __init__(self, **kwargs):
        # Warning: the init method will be called every time before the post() method
        # Don't use it to initialise or load files.
        # We will use kwargs to specify already initialised objects that are required to the bot
        super(GreetingsBot, self).__init__(bot_name=BOT_NAME)
        self.greetings = [
            "It's sunny",
            "It's windy",
            "Innae good time to gettout innit ?"
        ]
        
        self.intents = [
        	"air_quality_forecast",
        	"air_quality_today",
        	"air_quality_historical"
        ]
        
        self.entities = {
        	"good":["good", "great", "nice"],
        	"hierarchy_number":["next","future"] + [str(i) for i in range(10)],
        	"time_measures":["day","week","month","year"]
        }
        
        # loading the model from one directory or zip file
		self.interpreter = Interpreter.load(MODEL)
		

    def get(self):
        pass

	def get_response_from_rasa_interpretation(interpretation):
		intent = interpretation['intent']
		
		returned_response = "I did not get that. Could you repeat ?"
		
		if intent == "air_quality_today":
			r = requests.get(url=API_URL)
			response = r.json()
			returned_response = f"""
			Today's air is as follows:
				- h: {response['data']['h']['v']}
				- no2: {response['data']['no2']['v']}
				- o3: {response['data']['o3']['v']}
				- p: {response['data']['p']['v']}
				- pm10: {response['data']['pm10']['v']}
				- pm25: {response['data']['pm25']['v']}
				- so2: {response['data']['so2']['v']}
			"""		
			
			
			
		return returned_response


    def post(self):
        # This method will be executed for every POST request received by the server on the
        # "/" endpoint (see below 'add_resource')

        # We assume that the body of the incoming request is formatted as JSON (i.e., its Content-Type is JSON)
        # We parse the JSON content and we obtain a dictionary object
        request_data = request.get_json(force=True)

        # We wrap the resulting dictionary in a custom object that allows data access via dot-notation
        request_data = DictQuery(request_data)

        # We extract several information from the state
        user_utterance = request_data.get("current_state.state.nlu.annotations.processed_text")
        last_bot = request_data.get("current_state.state.last_bot")

        logger.info("------- Turn info ----------")
        logger.info("User utterance: {}".format(user_utterance))
        logger.info("Last bot: {}".format(last_bot))
        logger.info("---------------------------")
        logger.info("Sending to rasa interpreter...")
        
		# parsing the utterance
		interpretation = self.interpreter.parse(utterance)

		get_response_from_rasa_interpretation(interpretation)

        # the 'result' member is intended as the actual response of the bot
        self.response.result = random.choice(self.greetings)
        # we store in the dictionary 'bot_params' the current time. Remember that this information will be stored
        # in the database only if the bot is selected
        self.response.bot_params["time"] = str(datetime.now())

        # The response generated by the bot is always considered as a list (we allow a bot to generate multiple response
        # objects for the same turn). Here we create a singleton list with the response in JSON format
        return [self.response.toJSON()]





if __name__ == "__main__":
    args = parser.parse_args()
    
    if not os.path.exists("logs/"):
        os.makedirs("logs/")

    log.set_logger_params(BOT_NAME + '-' + BRANCH, logfile=args.logfile,
                          file_level=args.file_verbosity, console_level=args.console_verbosity)

    api.add_resource(GreetingsBot, "/")

    app.run(host="0.0.0.0", port=args.port)
